{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\nsonar DistanceFront = sonar(PORT3);\nmotor leftMotorA = motor(PORT5, 1, false);\nmotor leftMotorB = motor(PORT4, 1, false);\nmotor_group LeftDriveSmart = motor_group(leftMotorA, leftMotorB);\nmotor rightMotorA = motor(PORT11, 1, true);\nmotor rightMotorB = motor(PORT10, 1, true);\nmotor_group RightDriveSmart = motor_group(rightMotorA, rightMotorB);\ngyro DrivetrainGyro = gyro(PORT7, true);\nsmartdrive Drivetrain = smartdrive(LeftDriveSmart, RightDriveSmart, DrivetrainGyro, 200);\n\nmotor Bashna = motor(PORT6, false);\nmotor StrelaMotorA = motor(PORT9, false);\nmotor StrelaMotorB = motor(PORT12, false);\nmotor_group Strela = motor_group(StrelaMotorA, StrelaMotorB);\n\nbumper StrelaStopper = bumper(PORT2);\nmotor Kovsh = motor(PORT8, false);\ncolorsensor DrivetrainColor = colorsensor(PORT1);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double BrainTime = Brain.Timer.system() * 1000;\n  double BrainVoltage = Brain.Battery.voltage();\n  // Combine these values into a single integer\n  int seed = int(\n    BrainTime + BrainVoltage\n  );\n  // Set the seed\n  srand(seed); \n}\n\nbool vexcode_initial_drivetrain_calibration_completed = false;\nvoid calibrateDrivetrain() {\n  wait(200, msec);\n  Brain.Screen.print(\"Calibrating\");\n  Brain.Screen.newLine();\n  Brain.Screen.print(\"Gyro\");\n  DrivetrainGyro.calibrate();\n  while (DrivetrainGyro.isCalibrating()) {\n    wait(25, msec);\n  }\n  vexcode_initial_drivetrain_calibration_completed = true;\n  // Clears the screen and returns the cursor to row 1, column 1.\n  Brain.Screen.clearScreen();\n  Brain.Screen.setCursor(1, 1);\n}\n\nvoid vexcodeInit() {\n\n  // Calibrate the Drivetrain\n  calibrateDrivetrain();\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n#include \"iq_cpp.h\"\n\n// Drivetrain params\n#define DT_VEL 25  // Percent\n#define DT_TURN_VEL 75  // Percent\n\n#define DTCOLOR_LIGHT 100  // Percent\n#define DTCOLOR_BRIGHTNESS_THRESHOLD 90  // Threshold of color detect, percent \n\n#define CUB_STOP_DIST 75  // mm front of cub\n#define DIST_PP 0.109\n#define WAIT_BEFORE_STOP 100  // msec\n#define FRONT_OF_COLOR 40  // mm front of color\n\n#define DIST_BACK_DIF1 40  // mm\n#define DIST_BACK_DIF2 40  // mm\n\n// Strela params\n#define STRELA_A_SETUP_VEL 100  // Percent\n#define STRELA_B_SETUP_VEL 25  // Percent\n#define STRELA_A_DEF_POS 175  // Degrees after stopper pressing\n#define STRELA_A_CALIBRATE_DIF 500  // Degrees\n#define STRELA_B_DEF_POS 50  // mm front of distance\n#define STRELA_B_UNSPIN_TIME 80  // msec\n#define STRELA_B_CAL_DELAY 10  // msec\n\n#define STRELA_A_VEL 50  // Percent\n#define STRELA_B_VEL 50  // Percent\n\n/////////////////////////////////////////////////////////\n\n#define STRELA_A_FOR1 720  // Degrees\n#define STRELA_B_UP1 360  // Degrees\n#define STRELA_B_UP2 360  // Degrees\n\n#define STRELA_A_FOR3 520  // Degrees\n#define STRELA_B_DOWN3 560  // Degrees\n\n// Kovsh params\n#define KOVSH_VEL 50  // Percent\n#define KOVSH_CLOSE 360  // Degrees\n\n// Bashna params\n#define BASHNA_VEL 50  // Percent\n\n// Another params\n#define BATTERY_LIMIT 50  // Percent\n#define WAIT_BETWEEN_DO 500  // msec\n#define END_SOUND alarm  // Play sound after complete\n\n\nusing namespace vex;\n\nfloat turn_angle = 90.0f;\n\nvoid setup();\n\nint getCubsNum();\nvoid doCub();\nvoid turnTo(float tAngle);\nvoid doGreenColor(int& drived_dist);\nvoid endPoint(int& drived_dist);\n\nint driveToColor(colorType& cur_color);\n\nvoid setupStrela();\nvoid pullUpCub();\nvoid pushDownCub();\n\n\n/////////////////////////////////////////////////////////\n// Main functions\n/////////////////////////////////////////////////////////\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n\n  // Begin project code\n  setup();\n  int cubs_num = getCubsNum();\n  wait(WAIT_BETWEEN_DO, msec);\n\n  for (int i = 1; i <= cubs_num; i++) doCub();\n  Brain.playSound(END_SOUND);\n}\n\n/////////////////////////////////////////////////////////\n\nvoid setup() {\n  if (Brain.Battery.capacity(percent) < BATTERY_LIMIT) {\n    Brain.Screen.clearScreen(); Brain.Screen.setCursor(1, 1);\n    Brain.Screen.print(\"Low battery: %d\", Brain.Battery.capacity(percent)); Brain.Screen.print(\"%%\");\n    wait(1, seconds);\n    exit(0);\n  }\n\n  calibrateDrivetrain();\n  Drivetrain.setDriveVelocity(DT_VEL, percent);\n  Drivetrain.setTurnVelocity(DT_TURN_VEL, percent);\n  DrivetrainColor.setLight(DTCOLOR_LIGHT, percent);\n\n  Kovsh.setVelocity(KOVSH_VEL, percent);\n  Bashna.setVelocity(BASHNA_VEL, percent);\n}\n\n/////////////////////////////////////////////////////////\n\nint getCubsNum() {\n  Brain.Screen.clearScreen(); Brain.Screen.setCursor(1, 1);\n  Brain.Screen.print(\"Press button Up and\");\n  Brain.Screen.setCursor(2, 1);\n  Brain.Screen.print(\"Down to set cubs num.\");\n  \n  unsigned int cubs_num = 1;\n\n  while (!Brain.buttonCheck.pressing()) {\n    static bool last_up_btn = false;\n    static bool last_down_btn = false;\n\n    bool cur_up_btn = Brain.buttonUp.pressing();\n    bool cur_down_btn = Brain.buttonDown.pressing();\n\n    if (last_up_btn == 0 && cur_up_btn == 1) cubs_num++;\n    else if (last_down_btn == 0 && cur_down_btn == 1 && cubs_num > 0) cubs_num--;\n\n    last_up_btn = cur_up_btn;\n    last_down_btn = cur_down_btn;\n\n    Brain.Screen.clearLine(5); Brain.Screen.setCursor(5, 1);\n    Brain.Screen.print(\"Cubs num: %d\", cubs_num);\n\n    wait(10, msec);\n  }\n\n  wait(WAIT_BETWEEN_DO, msec);\n  Brain.Screen.clearScreen(); Brain.Screen.setCursor(1, 1);\n\n  return cubs_num;\n}\n\nvoid doCub() {\n  setupStrela();\n\n  colorType cur_color;\n  int drived_dist = driveToColor(cur_color);\n\n  if (cur_color == blue || cur_color == blue_green) doGreenColor(drived_dist);\n  else if (cur_color == red || cur_color == red_violet || cur_color == violet) {\n    Drivetrain.driveFor(reverse, drived_dist + DIST_BACK_DIF1, mm);\n    turnTo(-turn_angle);\n\n    if (Drivetrain.rotation(degrees) != -turn_angle) Drivetrain.turnToRotation(-turn_angle, degrees);\n    calibrateDrivetrain();\n\n    drived_dist = driveToColor(cur_color);\n    doGreenColor(drived_dist);\n  }\n}\n\nvoid turnTo(float tAngle) {\n  static bool dir_checked = false;\n  Drivetrain.turnToRotation(tAngle, degrees, dir_checked);\n\n  if (dir_checked == false) {\n    while (Drivetrain.isMoving()) {\n      if (DrivetrainColor.brightness() < DTCOLOR_BRIGHTNESS_THRESHOLD) {\n        turn_angle = -turn_angle;\n\n        Drivetrain.stop();\n        Drivetrain.turnToRotation(-tAngle, degrees);\n        \n        break;\n      }\n      wait(1, msec);\n    }\n    dir_checked = true;\n  }\n}\n\nvoid doGreenColor(int& drived_dist) {\n  colorType cur_color;\n\n  pullUpCub();\n\n  Drivetrain.driveFor(reverse, drived_dist + DIST_BACK_DIF1, mm);\n  turnTo(turn_angle);\n\n  if (Drivetrain.rotation(degrees) != turn_angle) Drivetrain.turnToRotation(turn_angle, degrees);\n\n  drived_dist = driveToColor(cur_color);\n\n  if (cur_color == red || cur_color == red_violet || cur_color == violet) endPoint(drived_dist);\n  else {\n    Drivetrain.driveFor(reverse, drived_dist, mm);\n    Drivetrain.turnToRotation(turn_angle, degrees);\n\n    drived_dist = driveToColor(cur_color);\n    endPoint(drived_dist);\n  }\n}\n\nvoid endPoint(int& drived_dist) {\n  pushDownCub();\n\n  Drivetrain.driveFor(reverse, drived_dist + DIST_BACK_DIF2, mm);\n  Drivetrain.turnToRotation(0, degrees);\n\n  if (Drivetrain.rotation(degrees) != 0.0f) Drivetrain.turnToRotation(0, degrees);\n\n  wait(WAIT_BETWEEN_DO, msec);\n}\n\n/////////////////////////////////////////////////////////\n// Drivetrain functions\n/////////////////////////////////////////////////////////\n\nint driveToColor(colorType& cur_color) {\n  float drived_dist = 0;\n\n  Drivetrain.drive(forward);\n  while (DrivetrainColor.brightness() >= DTCOLOR_BRIGHTNESS_THRESHOLD) {\n    if (DistanceFront.distance(mm) <= CUB_STOP_DIST) break;\n    drived_dist += DIST_PP;\n    wait(1, msec);\n  }\n  wait(WAIT_BEFORE_STOP, msec);\n  Drivetrain.stop();\n\n  cur_color = DrivetrainColor.colorname();\n  Drivetrain.driveFor(reverse, FRONT_OF_COLOR, mm);\n\n  return round(drived_dist);\n}\n\n/////////////////////////////////////////////////////////\n// Strela functions\n/////////////////////////////////////////////////////////\n\nvoid setupStrela() {\n  StrelaMotorA.setVelocity(STRELA_A_SETUP_VEL, percent);\n  StrelaMotorB.setVelocity(STRELA_B_SETUP_VEL, percent);\n\n  StrelaMotorA.spin(reverse);\n  \n  while (!StrelaStopper.pressing()) wait(1, msec);\n  StrelaMotorA.stop();\n\n  StrelaMotorA.spinFor(forward, STRELA_A_DEF_POS + STRELA_A_CALIBRATE_DIF, degrees);\n\n  if (DistanceFront.distance(mm) >= STRELA_B_DEF_POS + 5) {\n    float last_pos = 0;\n    int unspin_time = 0;\n\n    StrelaMotorB.spin(forward);\n\n    while (DistanceFront.distance(mm) > STRELA_B_DEF_POS) {\n      float cur_pos = StrelaMotorB.position(degrees);\n      if (cur_pos == last_pos) {\n        if (unspin_time >= STRELA_B_UNSPIN_TIME) break;\n        unspin_time += STRELA_B_CAL_DELAY;\n      }\n\n      last_pos = cur_pos;\n      wait(STRELA_B_CAL_DELAY, msec);\n    }\n    \n    StrelaMotorB.stop();\n  }\n\n  StrelaMotorA.spinFor(reverse, STRELA_A_CALIBRATE_DIF, degrees);\n  StrelaMotorA.setPosition(0, degrees);\n  StrelaMotorB.setPosition(0, degrees);\n\n  StrelaMotorA.setVelocity(STRELA_A_VEL, percent);\n  StrelaMotorB.setVelocity(STRELA_B_VEL, percent);\n}\n\nvoid pullUpCub() {\n  StrelaMotorA.spinFor(forward, STRELA_A_FOR1, degrees, false);\n  StrelaMotorB.spinFor(reverse, STRELA_B_UP1, degrees);\n  wait(WAIT_BETWEEN_DO, msec);\n\n  Kovsh.spinFor(forward, KOVSH_CLOSE, degrees);\n  wait(WAIT_BETWEEN_DO, msec);\n\n  StrelaMotorA.spinFor(reverse, STRELA_A_FOR1, degrees, false);\n  StrelaMotorB.spinFor(reverse, STRELA_B_UP2, degrees);\n  wait(WAIT_BETWEEN_DO, msec);\n}\n\nvoid pushDownCub() {\n  StrelaMotorA.spinFor(forward, STRELA_A_FOR3, degrees, false);\n  StrelaMotorB.spinFor(forward, STRELA_B_DOWN3, degrees);\n  wait(WAIT_BETWEEN_DO, msec);\n\n  Kovsh.spinFor(reverse, KOVSH_CLOSE, degrees);\n  wait(WAIT_BETWEEN_DO, msec);\n}\n","textLanguage":"cpp","robotConfig":[{"port":[3],"name":"DistanceFront","customName":true,"deviceType":"Distance","deviceClass":"sonar","setting":{},"triportSourcePort":22},{"port":[5,4,11,10,7],"name":"Drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"4-motor","wheelSize":"200mm","gearRatio":"1:1","direction":"fwd","gyroType":"smart","width":"173","unit":"mm","wheelbase":"76","wheelbaseUnit":"mm","xOffset":"0","yOffset":"0","thetaOffset":"0"},"triportSourcePort":22},{"port":[6],"name":"Bashna","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"вперёд","rev":"обратно"},"triportSourcePort":22},{"port":[9,12],"name":"Strela","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"вперёд","rev":"обратно","motor_a_reversed":"false","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[2],"name":"StrelaStopper","customName":true,"deviceType":"Bumper","deviceClass":"bumper","setting":{},"triportSourcePort":22},{"port":[8],"name":"Kovsh","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"вперёд","rev":"обратно"},"triportSourcePort":22},{"port":[1],"name":"DrivetrainColor","customName":true,"deviceType":"Color","deviceClass":"colorsensor","setting":{},"triportSourcePort":22}],"slot":2,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.0.7","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false}